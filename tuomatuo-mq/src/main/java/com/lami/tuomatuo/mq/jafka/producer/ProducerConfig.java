package com.lami.tuomatuo.mq.jafka.producer;

import com.lami.tuomatuo.mq.jafka.common.annotations.ClientSide;
import com.lami.tuomatuo.mq.jafka.message.CompressionCodec;
import com.lami.tuomatuo.mq.jafka.producer.async.AsyncProducerConfig;
import com.lami.tuomatuo.mq.jafka.producer.async.AsyncProducerConfigShared;
import com.lami.tuomatuo.mq.jafka.utils.Utils;
import com.lami.tuomatuo.mq.jafka.utils.ZkConfig;

import java.util.List;
import java.util.Properties;

/**
 * Created by xjk on 2016/10/19.
 */
@ClientSide
public class ProducerConfig extends ZkConfig implements SyncProducerConfigShared, AsyncProducerConfigShared {

    public SyncProducerConfigShared syncConfigShared;

    public AsyncProducerConfigShared asyncProducerConfigShared;

    public ProducerConfig(Properties props) {
        super(props);
        syncConfigShared = new SyncProducerConfig(props);
        asyncProducerConfigShared = new AsyncProducerConfig(props);
        check();
    }

    private void check(){

    }

    public Properties getProperties() {
        return props;
    }

    public int getBufferSize(){
        return syncConfigShared.getBufferSize();
    }

    public int getConnectTimeoutMs(){
        return syncConfigShared.getConnectTimeoutMs();
    }

    public int getSocketTimeoutMs(){
        return syncConfigShared.getSocketTimeoutMs();
    }

    public int getReconnectInterval(){
        return syncConfigShared.getReconnectInterval();
    }

    public int getReconnectTimeInterval(){
        return syncConfigShared.getReconnectTimeInterval();
    }

    public int getMaxMessageSize() {
        return syncConfigShared.getMaxMessageSize();
    }

    public int getmaxMessageSize(){
        return syncConfigShared.getMaxMessageSize();
    }

    public int getQueueTime() {
        return asyncProducerConfigShared.getQueueTime();
    }

    public int getQueueSize() {
        return asyncProducerConfigShared.getQueueSize();
    }

    public int getEnqueueTimeoutMs() {
        return asyncProducerConfigShared.getEnqueueTimeoutMs();
    }

    public int getBatchSize() {
        return asyncProducerConfigShared.getBatchSize();
    }

    public String getCbkHandler() {
        return asyncProducerConfigShared.getCbkHandler();
    }

    public Properties getCbkHandlerProperties() {
        return asyncProducerConfigShared.getCbkHandlerProperties();
    }

    public String getEventHandler() {
        return asyncProducerConfigShared.getEventHandler();
    }

    public Properties getEventHandlerProperties() {
        return asyncProducerConfigShared.getEventHandlerProperties();
    }

    /**
     * For bypassing zookeeper based auto partition discovery, use this config
     * to pass in static broker and per-broker partition information, Format
     * <pre>
     *     brokerid:host1:port1, brokerid2:host2:port2
     * </pre>
     */
    public String getBrokerList(){
        return Utils.getString(props, "broker.list", null);
    }

    /**
     * the partitioner class for partitioning events amongst sub-topics
     */
    public String getPartitionClass(){
        return Utils.getString(props, "partitioner.class", DefaultPartitioner.class.getName());
    }

    /**
     * This parameter allows you to specify the compression codec for all
     * data generated by this producer. The default is
     * {@link com.lami.tuomatuo.mq.jafka.message.CompressionCodec#NoCompressionCodec }
     *
     * @see com.lami.tuomatuo.mq.jafka.message.CompressionCodec#NoCompressionCodec
     */
    public CompressionCodec getCompressionCodec(){
        return CompressionCodec.valueof(Utils.getInt(props, "compression.codec", 0));
    }

    /**
     * This parameter allows you you to set whether compression should be
     * turned * on for particular topics
     *
     * If the compression only for specified topics if any
     *
     * Enable compression only for specify topics if any
     *
     * If the list of compressed topics ia empty, then enable the specified
     * compression codec for all topics
     *
     * If the compression codec is NoCompressionCodec, compression is
     * disable for all topics
     */
    public List<String> getCompressedTopics(){
        return Utils.getCSVList(Utils.getString(props, "compressed.topics", null));
    }

    /**
     * this parameter specifies whether the messages are sent
     * asynchronously or not, Valid values are
     *
     * <pre>
     *     async: for asynchronous send
     *     sync: for synchronous send
     * </pre>
     */
    public String getProducerType(){
        return Utils.getString(props, "producer.type", "sync");
    }

    /**
     *  The producer using the zookeeper software load balancer maintains a
     *  ZK cache that gets updated by the zookeeper watcher listeners
     *  During some events like a broker bounce, the producer ZK cache can
     *  get into an inconsistent state, for a small time period. In this
     *  time period, it could end up picking a broker partition that is unavailable
     *  when this happens, the ZK cache needs to be updated.
     *  This parameter specifies the number of times the producer attempts
     *  to refresh this ZK cache
     */
    public int getZkReadRetries(){
        return Utils.getInt(props, "zk.read.num.retries", 3);
    }
}
