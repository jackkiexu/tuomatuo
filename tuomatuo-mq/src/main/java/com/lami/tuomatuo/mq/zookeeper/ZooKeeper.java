package com.lami.tuomatuo.mq.zookeeper;

import com.lami.tuomatuo.mq.zookeeper.client.ConnectStringParser;
import com.lami.tuomatuo.mq.zookeeper.client.HostProvider;
import com.lami.tuomatuo.mq.zookeeper.client.StaticHostProvider;
import com.lami.tuomatuo.mq.zookeeper.client.ZooKeeperSaslClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Created by xujiankang on 2017/3/19.
 */
public class ZooKeeper {

    public static final String ZOOKEEPER_CLIENT_CNXN_SOCKET = "zokeeper.clientCnxnSocket";

    protected final ClientCnxn cnxn;
    private static final Logger LOG;

    static {
        // Keeper these two lines together to keep the initialization order explicit
        LOG = LoggerFactory.getLogger(ZooKeeper.class);
        Environment.logEnv("Client environment:", LOG);
    }

    public ZooKeeperSaslClient getSaslClient(){
        return cnxn.zooKeeperSaslClient;
    }

    private final ZKWatchManager watchManager = new ZKWatchManager();


    public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws IOException{
        LOG.info("Initiating client connection, connecString = " + connectString
                + " sessionTimeout = " + sessionTimeout + " watcher = " + watcher);
        watchManager.defaultWatcher = watcher;

        ConnectStringParser connectStringParser = new ConnectStringParser(connectString);
        HostProvider hostProvider = new StaticHostProvider(connectStringParser.getServerAddresses());
        cnxn = new ClientCnxn(connectStringParser.getChrootPath(),
                    hostProvider, sessionTimeout, this, watchManager,
                getClientCnxnSocket(), canBeReadOnly);
        cnxn.start();
    }




    /**
     * Register a watcher for a particular path
     */
    abstract class WatchRegistration {
        private Watcher watcher;
        private String clientPath;

        public WatchRegistration(Watcher watcher, String clientPath) {
            this.watcher = watcher;
            this.clientPath = clientPath;
        }

        abstract protected Map<String, Set<Watcher>> getWatches(int rc);

        /**
         * Register the watcher with the set of watches on path
         * @param rc the result code of the operation that attempted to
         *           add the watch on the path
         */
        public void register(int rc){
            if(shouldAddWatch(rc)){
                Map<String, Set<Watcher>> watches = getWatches(rc);
                synchronized (watches){
                    Set<Watcher> watchers = watches.get(clientPath);
                    if(watchers == null){
                        watchers = new HashSet<>();
                        watches.put(clientPath, watchers);
                    }
                    watchers.add(watcher);
                }
            }
        }

        /**
         * Determine whether the watch should be added based on return code.
         *
         * @param rc the result code of the operation that attempted to add the
         *           watch on the node
         * @return true if the watch should be added. otw false
         */
        protected boolean shouldAddWatch(int rc){
            return rc == 0;
        }
    }


    public enum States {
        CONNECTING, ASSOCIATING, CONNECTED, CONNECTEDREADONLY,
        CLOSED, AUTH_FAILED, NOT_CONNECTED;

        public boolean isAlive(){
            return this != CLOSED && this != AUTH_FAILED;
        }

        /**
         * Returns whether we are connected to a server (which
         * could possibly be read-only, if this client is allowed
         * to go to read-only mode)
         * @return
         */
        public boolean isConnected(){
            return this == CONNECTED || this == CONNECTEDREADONLY;
        }
    }

    /**
     * Manage watchers & handle events generated by the ClientCnxn object.
     *
     * We are implementing this as a nested class of ZooKeeper so that
     * the public methods will not be exposed as part of the ZooKeeper client
     * API.
     */
    private static class ZKWatchManager implements ClientWatchManager{

        private final Map<String, Set<Watcher>> dataWatches = new HashMap<>();
        private final Map<String, Set<Watcher>> existWatches = new HashMap<>();
        private final Map<String, Set<Watcher>> childWatches = new HashMap<>();

        private volatile Watcher defaultWatcher;


        @Override
        public Set<Watcher> materialize(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String path) {
            return null;
        }
    }

    private static ClientCnxnSocket getClientCnxnSocket() throws IOException{
        String clientCnxnSocketName = System.getProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET);
        if(clientCnxnSocketName == null){
            clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();
        }
        try {
            return (ClientCnxnSocket)Class.forName(clientCnxnSocketName).newInstance();
        }catch (Exception e){
            IOException ioe = new IOException("Couldn't instantiate" + clientCnxnSocketName);
            ioe.initCause(e);
            throw ioe;
        }
    }

}
