package com.lami.tuomatuo.mq.zookeeper;

import com.lami.tuomatuo.mq.zookeeper.client.*;
import com.lami.tuomatuo.mq.zookeeper.common.PathUtils;
import org.apache.zookeeper.data.ACL;
import org.apache.zookeeper.proto.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.*;

/**
 * Created by xujiankang on 2017/3/19.
 */
public class ZooKeeper {

    public static final String ZOOKEEPER_CLIENT_CNXN_SOCKET = "zokeeper.clientCnxnSocket";

    public static final String SECURE_CLIENT = "zookeeper.client.secure";

    protected final ClientCnxn cnxn;
    private static final Logger LOG;

    static {
        // Keeper these two lines together to keep the initialization order explicit
        LOG = LoggerFactory.getLogger(ZooKeeper.class);
        Environment.logEnv("Client environment:", LOG);
    }


    protected final HostProvider hostProvider;

    public void updateServerList(String connectString) throws IOException{
        ConnectStringParser connectStringParser = new ConnectStringParser(connectString);
        Collection<InetSocketAddress> serverAddresses = connectStringParser.getServerAddresses();
        ClientCnxnSocket clientCnxnSocket = cnxn.sendThread.getClientCnxnSocket();
        InetSocketAddress currentHost = (InetSocketAddress)clientCnxnSocket.getRemoteSocketAddress();

        boolean reconfigMode = hostProvider.updateServerList(serverAddresses, currentHost);
        /**
         * cause disconnection - this will cause next to be called
         * which will in turn call nextReconfigMode
         */
        if(reconfigMode){
            clientCnxnSocket.testableCloseSocket();
        }
    }

    public ZooKeeperSaslClient getSaslClient(){
        return cnxn.zooKeeperSaslClient;
    }

    private final ZKWatchManager watchManager;

    private final ZKClientConfig clientConfig;

    public ZKClientConfig getClientConfig() {
        return clientConfig;
    }


    protected List<String> getDataWatches(){
        synchronized (watchManager.dataWatches){
            List<String> rc = new ArrayList<>(watchManager.dataWatches.keySet());
            return rc;
        }
    }

    protected List<String> getExistWatches(){
        synchronized (watchManager.existWatches){
            List<String> rc = new ArrayList<>(watchManager.existWatches.keySet());
            return rc;
        }
    }


    protected List<String> getChildWatches(){
        synchronized (watchManager.childWatches){
            List<String> rc = new ArrayList<>(watchManager.childWatches.keySet());
            return rc;
        }
    }

    /**
     * Manage watchers & handle events generated by the ClientCnxn object.
     *
     * We are implementing this as a nested class of ZooKeeper so that
     * the public methods will not be exposed as part of the ZooKeeper client
     * API.
     */
    private static class ZKWatchManager implements ClientWatchManager{

        private final Map<String, Set<Watcher>> dataWatches = new HashMap<>();
        private final Map<String, Set<Watcher>> existWatches = new HashMap<>();
        private final Map<String, Set<Watcher>> childWatches = new HashMap<>();

        private boolean disableAutoWatchReset;

        public ZKWatchManager(boolean disableAutoWatchReset) {
            this.disableAutoWatchReset = disableAutoWatchReset;
        }

        private volatile Watcher defaultWatcher;

        final private void addTo(Set<Watcher> from, Set<Watcher> to){
            if(from != null){
                to.addAll(from);
            }
        }

        public Map<Watcher.Event.EventType, Set<Watcher>> removeWatcher(String clientPath,
                                                                        Watcher watcher, Watcher.WatcherType watcherType, boolean local, int rc)
        throws KeeperException{
            // Validate the provided znode path contains the given watcher of
            // watcherType
            containsWatcher(clientPath, watcher, watcherType);

            Map<Watcher.Event.EventType, Set<Watcher>> removeWatchers = new HashMap<>();
            HashSet<Watcher> childWatchersToRem = new HashSet<>();
            removeWatchers.put(Watcher.Event.EventType.ChildWatchRemoved, childWatchersToRem);
            HashSet<Watcher> dataWatchersToRem = new HashSet<>();
            removeWatchers.put(Watcher.Event.EventType.DataWatchRemoved, dataWatchersToRem);
            boolean removedWatcher = false;
            switch (watcherType) {
                case Children: {
                    synchronized (childWatches) {
                        removedWatcher = removeWatchers(childWatches, watcher, clientPath, local, rc, childWatchersToRem);
                    }
                    break;
                }
                case Data: {
                    synchronized (dataWatches) {
                        removedWatcher = removeWatchers(dataWatches, watcher, clientPath, local, rc, dataWatchersToRem);
                    }
                    synchronized (existWatches) {
                        boolean removeDataWatcher = removeWatchers(existWatches, watcher, clientPath, local, rc, dataWatchersToRem);
                        removedWatcher |= removeDataWatcher;
                    }
                    break;
                }
                case Any: {
                    synchronized (childWatches) {
                        removedWatcher = removeWatchers(childWatches, watcher, clientPath, local, rc, childWatchersToRem);
                    }

                    synchronized (dataWatches) {
                        boolean removeDataWatcher = removeWatchers(dataWatches, watcher, clientPath, local, rc, dataWatchersToRem);
                        removedWatcher |= removeDataWatcher;
                    }

                    synchronized (existWatches) {
                        boolean removeDataWatcher = removeWatcher(existWatches, watcher, clientPath, local, rc, dataWatchersToRem);
                        removeDataWatcher |= removeDataWatcher;
                    }
                }
            }

            // Watcher function doesn't exists for the specified params
            if(!removedWatcher){
                throw new KeeperException.NoWatcherException();
            }
            return removeWatchers;

        }

        private boolean contains(String path, Watcher watcherObj, Map<String, Set<Watcher>> pathVsWatchers){
            boolean watcherExists = true;
            if(pathVsWatchers == null || pathVsWatchers.size() == 0){
                watcherExists = false;
            }else{
                Set<Watcher> watchers = pathVsWatchers.get(path);
                if(watchers == null){
                    watcherExists = false;
                }else if(watcherObj == null){
                    watcherExists = watchers.size() > 0;
                }else{
                    watcherExists = watchers.contains(watcherObj);
                }
            }

            return watcherExists;
        }

        /**
         * Validate the provided znode path contains the given watcher and
         * watcherType
         * @param path
         * @param watcher
         * @param watcherType
         * @throws KeeperException.NoWatcherException
         */
        void containsWatcher(String path, Watcher watcher,
                             Watcher.WatcherType watcherType)
        throws KeeperException.NoWatcherException{
            boolean containsWatcher = false;
            switch (watcherType){
                case Children:{
                    synchronized (childWatches){
                        containsWatcher = contains(path, watcher, childWatches);
                    }
                    break;
                }
                case Data:{
                    synchronized (dataWatches){
                        containsWatcher = contains(path, watcher, dataWatches);
                    }
                    synchronized (existWatches){
                        boolean contains_temp = contains(path, watcher, existWatches);
                        containsWatcher |= contains_temp;
                    }
                    break;
                }
                case Any:{
                    synchronized (childWatches){
                        containsWatcher = contains(path, watcher, childWatches);
                    }
                    synchronized (dataWatches){
                        boolean contains_temp = contains(path, watcher, dataWatches);
                        containsWatcher |= contains_temp;
                    }
                    synchronized (existWatches){
                        boolean contains_temp = contains(path, watcher, existWatches);
                        containsWatcher |= contains_temp;
                    }
                }
            }

            // Watcher function doesn't exist for the specified params
            if(!containsWatcher){
                throw new KeeperException.NoWatcherException();
            }
        }

        protected boolean removeWatchers(Map<String, Set<Watcher>> pathVsWatcher, Watcher watcher, String path, boolean local, int rc,
                                         Set<Watcher> removeWatchers) throws Exception{
            if(!local && rc != KeeperException.Code.OK.intValue()){
                throw KeeperException.create(KeeperException.Code.get(rc), path);
            }
            boolean success = false;
            /**
             * When local flag is true, remove watchers for the given path
             * irrespective of rc. Otherwise shouldn't remove watchers locally
             * when sees failure from server
             */
            if(rc == KeeperException.Code.OK.intValue() || (local && rc != KeeperException.Code.OK.intValue())){
                // Remove all the watchers for the given path
                if(watcher == null){
                    Set<Watcher> pathWatchers = pathVsWatcher.remove(path);
                    if(pathWatchers != null){
                        // found path watchers
                        removeWatchers.addAll(pathWatchers);
                        success = true;
                    }
                }
                else{
                    Set<Watcher> watchers = pathVsWatcher.get(path);
                    if(watchers.remove(watcher)){
                        // found path watcher
                        removeWatchers.add(watcher);
                        // cleanup < path vs watchList
                        if(watchers.size() <= 0){
                            pathVsWatcher.remove(path);
                        }
                        success = true;
                    }
                }
            }

            return success;
        }




        @Override
        public Set<Watcher> materialize(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String path) {
            Set<Watcher> result = new HashSet<>();

            return null;
        }
    }


    /**
     * Register a watcher for a particular path
     */
    abstract class WatchRegistration {
        private Watcher watcher;
        private String clientPath;

        public WatchRegistration(Watcher watcher, String clientPath) {
            this.watcher = watcher;
            this.clientPath = clientPath;
        }

        abstract protected Map<String, Set<Watcher>> getWatches(int rc);

        /**
         * Register the watcher with the set of watches on path
         * @param rc the result code of the operation that attempted to
         *           add the watch on the path
         */
        public void register(int rc){
            if(shouldAddWatch(rc)){
                Map<String, Set<Watcher>> watches = getWatches(rc);
                synchronized (watches){
                    Set<Watcher> watchers = watches.get(clientPath);
                    if(watchers == null){
                        watchers = new HashSet<>();
                        watches.put(clientPath, watchers);
                    }
                    watchers.add(watcher);
                }
            }
        }

        /**
         * Determine whether the watch should be added based on return code.
         *
         * @param rc the result code of the operation that attempted to add the
         *           watch on the node
         * @return true if the watch should be added. otw false
         */
        protected boolean shouldAddWatch(int rc){
            return rc == 0;
        }
    }


    /**
     * Handle the special case of exist watches - they add a watcher
     * even in the case where NONODe result code is returned
     */
    class ExistsWatchRegistration extends WatchRegistration{
        public ExistsWatchRegistration(Watcher watcher, String clientPath) {
            super(watcher, clientPath);
        }

        @Override
        protected Map<String, Set<Watcher>> getWatches(int rc) {
            return rc == 0? watchManager.dataWatches : watchManager.existWatches;
        }

        @Override
        protected boolean shouldAddWatch(int rc) {
            return rc == 0 || rc == KeeperException.Code.NONODE.intValue();
        }
    }

    class DataWatchRegistration extends WatchRegistration{
        public DataWatchRegistration(Watcher watcher, String clientPath) {
            super(watcher, clientPath);
        }

        @Override
        protected Map<String, Set<Watcher>> getWatches(int rc) {
            return watchManager.dataWatches;
        }
    }

    class ChildWatchRegistration extends WatchRegistration{
        public ChildWatchRegistration(Watcher watcher, String clientPath) {
            super(watcher, clientPath);
        }

        @Override
        protected Map<String, Set<Watcher>> getWatches(int rc) {
            return watchManager.childWatches;
        }
    }


    public enum States {
        CONNECTING, ASSOCIATING, CONNECTED, CONNECTEDREADONLY,
        CLOSED, AUTH_FAILED, NOT_CONNECTED;

        public boolean isAlive(){
            return this != CLOSED && this != AUTH_FAILED;
        }

        /**
         * Returns whether we are connected to a server (which
         * could possibly be read-only, if this client is allowed
         * to go to read-only mode)
         * @return
         */
        public boolean isConnected(){
            return this == CONNECTED || this == CONNECTEDREADONLY;
        }
    }



    public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)throws IOException{
        this(connectString, sessionTimeout, watcher, false);
    }

    public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws IOException{
        LOG.info("Initiating client connection, connecString = " + connectString
                + " sessionTimeout = " + sessionTimeout + " watcher = " + watcher);
        watchManager.defaultWatcher = watcher;

        ConnectStringParser connectStringParser = new ConnectStringParser(connectString);
        HostProvider hostProvider = new StaticHostProvider(connectStringParser.getServerAddresses());
        cnxn = new ClientCnxn(connectStringParser.getChrootPath(),
                hostProvider, sessionTimeout, this, watchManager,
                getClientCnxnSocket(), canBeReadOnly);
        cnxn.start();
    }

    public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,
                     long sessionId, byte[] sessionPasswd, boolean canBeReadOnly)
            throws IOException
    {
        LOG.info("Initiating client connection, connectString=" + connectString
                + " sessionTimeout=" + sessionTimeout
                + " watcher=" + watcher
                + " sessionId=" + Long.toHexString(sessionId)
                + " sessionPasswd="
                + (sessionPasswd == null ? "<null>" : "<hidden>"));

        watchManager.defaultWatcher = watcher;

        ConnectStringParser connectStringParser = new ConnectStringParser(
                connectString);
        HostProvider hostProvider = new StaticHostProvider(
                connectStringParser.getServerAddresses());
        cnxn = new ClientCnxn(connectStringParser.getChrootPath(),
                hostProvider, sessionTimeout, this, watchManager,
                getClientCnxnSocket(), sessionId, sessionPasswd, canBeReadOnly);
        cnxn.seenRwServerBefore = true; // since user has provided sessionId
        cnxn.start();
    }

    public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher, long sessionId, byte[] sessionPasswd) throws IOException{
        this(connectString, sessionTimeout, watcher, sessionId, sessionPasswd, false);
    }

    /**
     * The session id for this ZooKeeper client instance. The value returned is
     * not valid until the client connects to a server and may change after a
     * re-connect
     * @return
     */
    public long getSessionId(){
        return cnxn.getSessionId();
    }

    /**
     * The session password for this ZooKeeper client instance. The value
     * returned is not valid until the client connects to a server and may
     * change after a re-connect
     *
     * This method is NOT thread safe
     *
     * @return
     */
    public byte[] getSessionPasswd(){
        return cnxn.getSessionPasswd();
    }

    /**
     * The negotiated session timeout for this ZooKeeper client instance. The
     * value returned is not valid until the client connects to a server and
     * may change after a re-connect
     *
     * @return current session timeout
     */
    public int getSessionTimeout(){
        return cnxn.getSessionTimeout();
    }

    /**
     * Add the specified scheme:auth information to this connection
     * This method is NOT thread safe
     *
     * @param scheme
     * @param auth
     */
    public void addAuthInfo(String scheme, byte auth[]){
        cnxn.addAuthInfo(scheme, auth);
    }

    /**
     * Specify the default watcher for the connection (overrides the one
     * specified during construction)
     * @param watcher
     */
    public synchronized void register(Watcher watcher){
        watchManager.defaultWatcher = watcher;
    }


    public synchronized void close() throws InterruptedException{
        if(!cnxn.getState().isAlive()){
            LOG.info("Close called on already closed client");
            return;
        }

        try {
            cnxn.close();
        } catch (IOException e) {
            e.printStackTrace();
            LOG.info("Ignoring unexpected exception during close", e);
        }

        LOG.info("Session: 0x : " + Long.toHexString(getSessionId()) + " closed");
    }

    /**
     * Prepend the chroot to the client path (if present). The expectation of
     * this function is that the client path has been validated before this
     * function is called
     *
     * @param clientPath path to the node
     * @return server view of the path (chroot prepended to client path)
     */
    private String prependChroot(String clientPath){
        if(cnxn.chrootPath != null){
            // handle clientPath = '/'
            if(clientPath.length() == 1){
                return cnxn.chrootPath;
            }
            return cnxn.chrootPath + clientPath;
        }else{
            return clientPath;
        }
    }



    public String create(final String path, byte data[], List<ACL> acl, CreateMode createMode) throws KeeperException, InterruptedException{
        final String clientPath = path;
        PathUtils.validatePath(clientPath, createMode.isSequential());
        final String serverPath = prependChroot(clientPath);

        RequestHeader h = new RequestHeader();
        h.setType(ZooDefs.OpCode.create);
        CreateRequest request = new CreateRequest();
        CreateResponse response = new CreateResponse();
        request.setData(data);
        request.setFlags(createMode.toFlag());
        request.setPath(serverPath);

        if(acl != null && acl.size() == 0){
            throw new KeeperException.InvalidACLException();
        }
        request.setAcl(acl);
        ReplyHeader r = cnxn.submitRequest(h, request, response, null);
        if(r.getErr() != 0){
            throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);
        }

        if(cnxn.chrootPath == null){
            return response.getPath();
        }else{
            return response.getPath().substring(cnxn.chrootPath.length());
        }
    }

    public void create(final String path, byte data[], List<ACL> acl, CreateMode createMode,
                       AsyncCallback.StringCallback cb, Object ctx){
        final String clientPath = path;
        PathUtils.validatePath(clientPath, createMode.isSequential());

        final String serverPath = prependChroot(clientPath);

        RequestHeader h = new RequestHeader();
        h.setType(ZooDefs.OpCode.create);

        CreateRequest request = new CreateRequest();
        CreateResponse response = new CreateResponse();
        ReplyHeader r = new ReplyHeader();
        request.setData(data);
        request.setFlags(createMode.toFlag());
        request.setPath(serverPath);
        request.setAcl(acl);
        cnxn.queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, null);
    }


    public void delete(final String path, int version)throws InterruptedException, KeeperException{
        final String clientPath = path;
        PathUtils.validatePath(clientPath);

        final String serverPath;

        /**
         * maintain semantics even in chroot case
         * specifically - root cannot deleted
         * I think this makes sense even in chroot case
         */

        if(clientPath.equals("/")){
            /**
             * a bit of a hack, but delete(/) will never succeed and ensures
             * that the same semantics are maintained
             */
            serverPath = clientPath;
        }else {
            serverPath = prependChroot(clientPath);
        }

        RequestHeader h = new RequestHeader();
        h.setType(ZooDefs.OpCode.delete);
        DeleteRequest request = new DeleteRequest();
        request.setPath(serverPath);
        request.setVersion(version);
        ReplyHeader r = cnxn.submitRequest(h, request, null, null);
        if(r.getErr() != 0){
            throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);
        }

    }


    public List<OpResult> multi(Iterable<Op> ops) throws InterruptedException, KeeperException{
        for(Op op : ops){
            op.validate();
        }

        // reconstructing transaction with the chroot prefix
        List<Op> transaction = new ArrayList<Op>();
        for(Op op : ops){
            transaction.add(withRootPrefix(op));
        }
        return multiInternal(new MultiTransactionRecord(transaction));
    }


    public Op withRootPrefix(Op op){
        if(null != op.getPath()){
            final String serverPath = prependChroot(op.getPath());
            if(!op.getPath().equals(serverPath)){
                return op.withChroot(serverPath);
            }
        }
        return op;
    }


    protected List<OpResult> multiInternal(MultiTransactionRecord request)throws
        InterruptedException, KeeperException{
        RequestHeader h = new RequestHeader();
        h.setType(ZooDefs.OpCode.multi);
        MultiResponse response = new MultiResponse();
        ReplyHeader r = cnxn.submitRequest(h, request, response, null);
        if(r.getErr() != 0){
            throw KeeperException.create(KeeperException.Code.get(r.getErr()));
        }

        List<OpResult> results = response.getResultList();

        OpResult.ErrorResult fataError = null;

    }


    private static ClientCnxnSocket getClientCnxnSocket() throws IOException{
        String clientCnxnSocketName = System.getProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET);
        if(clientCnxnSocketName == null){
            clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();
        }
        try {
            return (ClientCnxnSocket)Class.forName(clientCnxnSocketName).newInstance();
        }catch (Exception e){
            IOException ioe = new IOException("Couldn't instantiate" + clientCnxnSocketName);
            ioe.initCause(e);
            throw ioe;
        }
    }

}
